using Rennala.Utility;

namespace Rennala.Logic.Zone
{
    static internal class Writer
    {
        private static readonly List<ZoneEntry> entries = new();
        private static readonly Dictionary<string, string> derivatives = new();

        /// <summary>
        /// Adds a new Zone Entry to the list to print to the .txt file
        /// </summary>
        public sealed class ZoneEntry
        {
            public readonly string _header;
            public readonly string _name;

            public ZoneEntry(string header, string name)
            {
                _header = header;
                _name = name;
            }
        }

        private static readonly Dictionary<string, Func<string, ZoneEntry>> ZoneEntries = new()
        {
            {"bulletweapon.gdf",                (name) => new ZoneEntry("weapon", name)},
            {"projectileweapon.gdf",            (name) => new ZoneEntry("weapon", name)},
            {"meleeweapon.gdf",                 (name) => new ZoneEntry("weapon", name)},
            {"grenadeweapon.gdf",               (name) => new ZoneEntry("weapon", name)},
            {"dualwieldweapon.gdf",             (name) => new ZoneEntry("weapon", name)},
            {"dualwieldprojectileweapon.gdf",   (name) => new ZoneEntry("weapon", name)},
            {"gasweapon.gdf",                   (name) => new ZoneEntry("weapon", name)},
            {"attachmentunique.gdf",            (name) => new ZoneEntry("attachmentunique", name)},
            {"charactercustomizationtable.gdf", (name) => new ZoneEntry("customizationtable", name)},
            {"scriptbundle.gdf",                (name) => new ZoneEntry("scriptbundle", name)}
        };

        /// <summary>
        /// Checks if the line is a zone entry
        /// </summary>
        /// <param name="line"> What line to check </param>
        /// <returns> Bool </returns>
        public static bool IsZoneEntry(string line)
        {
            if (Derivative.IsDerived(line))
            {
                Derivative.AddDerivative(line, derivatives);
                return false;
            }

            foreach (string entry in ZoneEntries.Keys)
            {
                if (line.Contains(entry))
                {
                    return true;
                }
            }

            return false;
        }

        /// <summary>
        /// Gets the correct callback for the type of asset
        /// </summary>
        /// <param name="key"> Header of the zone entry </param>
        /// <returns> Func </returns>
        private static Func<string, ZoneEntry> GetZoneEntryFunc(string key)
        {
            return ZoneEntries[key];
        }

        /// <summary>
        /// Handles all the logic on what to add to the txt file
        /// </summary>
        /// <param name="line"> What line to check on </param>
        public static void HandleZoneEntry(string line)
        {
            string[]? lines = line.Split('"');

            if (lines.Length == 0)
            {
                return;
            }

            string assetName = lines[1];
            string assetType = lines[3];

            Func<string, ZoneEntry> cb = GetZoneEntryFunc(assetType);
            ZoneEntry entry = cb(assetName);

            entries.Add(entry);
        }

        /// <summary>
        /// Writes the .txt file
        /// </summary>
        public static void Write()
        {
            if (entries.Count == 0)
            {
                return;
            }

            using FileStream zone = new(Path.Combine(Location.GetExeDirectory(), "RennalaOutput", "zone.txt"), FileMode.OpenOrCreate, FileAccess.Write);
            using StreamWriter zoneStreamer = new(zone);

            zoneStreamer.WriteLine("Zone auto-generated by Rennala - please ensure you add everything that needs to be added such as providing scripts, sounds, stringtables, materials, images, FX and more!\n");
            foreach (ZoneEntry entry in entries)
            {
                zoneStreamer.WriteLine($"{entry._header},{entry._name}");

                // Print out all the derivatives
                var derivative = entry._name;
                while (derivatives.ContainsValue(derivative))
                {
                    foreach (KeyValuePair<string, string> kvp in derivatives) // We have to loop through it, there can be multiple derivatives that come from the same asset
                    {
                        if (kvp.Value == derivative) // We store the value as the asset that it can be derived from, as values don't have to be unique
                        {
                            zoneStreamer.WriteLine($"{entry._header},{kvp.Key}"); // Key is the asset that is derived, so we print that out!
                        }
                    }

                    derivative = derivatives.FirstOrDefault(x => x.Value == derivative).Key;
                }
            }
        }
    }
}
